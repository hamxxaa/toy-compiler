# Toy Compiler

A simple compiler built from the ground up as a learning exercise in compiler theory and design. It translates a small, C-like toy language into 32-bit x86 assembly (nasm) for both Linux and Windows.

The primary goal of this project is to implement each stage of the compiler pipeline manually to gain a deeper understanding of the underlying concepts. This includes writing core components from scratch, such as the regex engine and code generator, without relying on standard libraries or tools like `re`, `yacc`, or `LLVM`.

## Language Features

The language is minimal but supports core procedural constructs:

  * **Types:** `int` and `bool`.
  * **Variables:** Declaration (`var int a;`) and initialization (`var int b = 10;`).
  * **Operators:** Arithmetic (`+`, `-`, `*`, `/`), relational (`<`, `>`, `==`, `!=`, `<=`, `>=`), and logical (`&`, `|`).
  * **Control Flow:** `if (condition) do ( ... )` and `while (condition) do ( ... )` statements.
  * **I/O:** A built-in `print(...)` function.

### Example Code

```
var int a = 10;
var int b = 20;
var int c = 5;
var int result;
result = a + b * c;
print(result);
```

*([examples/code.txt](https://www.google.com/search?q=hamxxaa/toy-compiler/toy-compiler-1ff4ec6a9e22db9219040255ca367cdefebe19bd/examples/code.txt))*

## Architecture & Pipeline

The compiler is built in stages, processing the source code in a classic pipeline:

1.  **Lexer (`src/lexer`):**

      * A hand-written **Regex Engine** based on Thompson's Construction (Regex -\> NFA).
      * A **Tokenizer** that uses the regex engine to convert the source string into a stream of tokens.

2.  **Parser (`src/parser`):**

      * A hand-written **Recursive Descent Parser** that consumes the token stream.
      * Produces an **Abstract Syntax Tree (AST)** as its output.

3.  **Analyzer (`src/analyzer`):**

      * A **Semantic Analyzer** that traverses the AST using a visitor pattern.
      * Manages a **Symbol Table** to perform type checking and detect undefined variables.

4.  **IR Generation (`src/codegen`):**

      * A **Three-Address Code (TAC)** generator that walks the (now validated) AST and produces a linear intermediate representation.

5.  **Optimization (`src/optimization`):**

      * An **Optimizer** that performs basic optimization passes on the TAC, such as *Constant Folding* and *Constant Propagation*.

6.  **Backend (`src/backend`):**

      * A hand-written **x86 (32-bit) Code Generator**.
      * This stage performs **Liveness Analysis** on the TAC to inform its **Greedy Register Allocator** before generating the final NASM-compatible assembly code.
      * Includes a small, necessary runtime (`runtime/runtime.asm`) for functions like `print_integer`.

## Usage

You can run the compiler directly using Python or via the provided platform scripts:

```bash
# Using Python directly
python3 main.py examples/code.txt

# Using scripts (Linux/macOS)
./scripts/compile.sh examples/code.txt

# Using scripts (Windows - CMD)
scripts\compile.bat examples/code.txt

# Using scripts (Windows - PowerShell)
powershell -ExecutionPolicy Bypass -File scripts\compile.ps1 examples/code.txt
```

The compiler will automatically assemble, link, and execute the code, placing build artifacts in the `build/` directory.

## Options

The `main.py` script accepts several flags, primarily for debugging the compiler's internal stages:

  * `-o, --output`: Specify the output executable name (default: `program`).
  * `--no-optimize`: Disables the optimization pass.
  * `--print-tokens`: Prints the token stream from the Lexer.
  * `--print-ast`: Prints a simple indented view of the AST.
  * `--print-tac`: Prints the un-optimized Three-Address Code.
  * `--print-optimized-tac`: Prints the optimized Three-Address Code.
  * `--save-asm`: Saves the generated assembly file (e.g., `temp.asm`) in the `build/objects` directory.

## Requirements

To build and run the code generated by this compiler, you will need:

  * Python 3.x
  * **NASM** (The Netwide Assembler)
  * A 32-bit system linker:
      * **Linux:** `ld` (usually part of `build-essential` or `binutils`)
      * **Windows:** `link.exe` (part of Visual Studio Build Tools)