; ================================================================
;  STANDARD LIBRARY
;  This section is appended to the end of every program generated by the compiler.
; ================================================================

print_integer:
    ; INPUT: 32-bit integer to print is expected in EAX register.
    ; OUTPUT: Prints the number to stdout.
    ; USED REGISTERS: eax, ebx, ecx, edx, edi, esi
    ; (ebx, ecx, edx, edi, esi are preserved at function start, restored at end)

    lea     edi, [buffer + 19] ; Go to the end of string buffer
    mov     byte [edi], 0      ; Null-terminate the string

    mov     ebx, 10            ; Divisor (for base 10)
    
    ; Check if the number is negative and store its sign
    xor     esi, esi           ; Use esi as sign flag (0=positive, 1=negative)
    test    eax, eax
    jns     .convert_loop      ; If positive or zero, start conversion directly
    
    ; If negative:
    mov     esi, 1             ; Record that it's negative
    neg     eax                ; Convert number to positive

.convert_loop:
    dec     edi                ; Move one character back in buffer
    xor     edx, edx           ; Clear edx for idiv
    idiv    ebx                ; eax = eax / 10, edx = eax % 10
    add     dl, '0'            ; Convert remainder (digit) to ASCII character
    mov     [edi], dl          ; Write ASCII character to buffer
    test    eax, eax           ; Is eax (quotient) zero?
    jnz     .convert_loop      ; If not zero, continue loop

.check_sign:
    cmp     esi, 1             ; Was the sign flag negative?
    jne     .print_string      ; If not, go to print string
    
    ; If negative, add '-' sign at the beginning
    dec     edi
    mov     byte [edi], '-'

.print_string:
    ; Calculate string length
    mov     ecx, edi           ; ecx = string start address
    lea     edx, [buffer + 19] ; edx = buffer end
    sub     edx, ecx           ; edx = length

    ; Prepare syscall for printing (sys_write)
    mov     eax, 4             ; syscall number (write)
    mov     ebx, 1             ; file descriptor (stdout)
    int     0x80               ; Call kernel

    ret                        ; Return to calling code

print_boolean:
    ; INPUT: Boolean value (0 or 1) in EAX register.
    ; OUTPUT: Prints "true" or "false" to stdout.
    ; USED REGISTERS: eax, ebx, ecx, edx
    ; (ebx, ecx, edx are preserved at function start, restored at end)

    ; Check if the boolean value is 0 (false) or 1 (true)
    test    eax, eax
    jz      .print_false       ; If zero, print "false"
    
    ; Print "true"
    mov     ecx, true_str      ; Address of "true" string
    mov     edx, 4             ; Length of "true"
    jmp     .do_print

.print_false:
    ; Print "false"
    mov     ecx, false_str     ; Address of "false" string
    mov     edx, 5             ; Length of "false"

.do_print:
    ; Prepare syscall for printing (sys_write)
    mov     eax, 4             ; syscall number (write)
    mov     ebx, 1             ; file descriptor (stdout)
    int     0x80               ; Call kernel

    ret                        ; Return to calling code

; --- Data section required for print_integer ---
section .data
    newline db 10
    true_str db 'true'
    false_str db 'false'

section .bss
    buffer resb 20             ; 20-byte buffer for string representation of number
